package com.thatdot.nauty.group

import scala.collection.mutable
import scala.util.Random

/**
 * Schreier-Sims algorithm for computing a Base and Strong Generating Set (BSGS)
 * of a permutation group.
 *
 * This allows:
 * - Accurate computation of group order
 * - Membership testing
 * - Enumeration of group elements
 *
 * Based on the randomized Schreier-Sims algorithm as implemented in nauty.
 */
object SchreierSims {

  /**
   * Compute a BSGS for the group generated by the given permutations.
   *
   * @param generators List of generators for the group
   * @param n          Degree of the permutation group (permutations act on 0..n-1)
   * @return A BSGS structure representing the group
   */
  def computeBSGS(generators: Seq[Permutation], n: Int): BSGS = {
    if (generators.isEmpty || n == 0) {
      return BSGS(Nil, n)
    }

    val bsgs = new BSGSBuilder(n)

    // Add all generators
    for (gen <- generators if !gen.isIdentity) {
      bsgs.addGenerator(gen)
    }

    // Expand using random Schreier products
    bsgs.expand()

    bsgs.toBSGS
  }

  /**
   * Compute the order of the group generated by the given permutations.
   *
   * @param generators List of generators
   * @param n          Degree of the group
   * @return The group order as a BigInt
   */
  def groupOrder(generators: Seq[Permutation], n: Int): BigInt = {
    val bsgs = computeBSGS(generators, n)
    bsgs.order
  }

  /**
   * Test if a permutation is in the group generated by the given generators.
   *
   * @param perm       The permutation to test
   * @param generators The generators of the group
   * @param n          Degree of the group
   * @return true if perm is in the group
   */
  def isMember(perm: Permutation, generators: Seq[Permutation], n: Int): Boolean = {
    val bsgs = computeBSGS(generators, n)
    bsgs.contains(perm)
  }
}

/**
 * A Base and Strong Generating Set (BSGS) representation of a permutation group.
 *
 * @param levels The stabilizer chain levels
 * @param n      Degree of the group
 */
case class BSGS(levels: List[StabilizerLevel], n: Int) {

  /**
   * Compute the order of the group.
   * This is the product of orbit sizes at each level.
   */
  def order: BigInt = {
    if (levels.isEmpty) BigInt(1)
    else levels.map(level => BigInt(level.orbitSize)).product
  }

  /**
   * Test if a permutation is in the group.
   */
  def contains(perm: Permutation): Boolean = {
    sift(perm)._2
  }

  /**
   * Sift a permutation through the stabilizer chain.
   *
   * @param perm The permutation to sift
   * @return (residue, isIdentity) where residue is what remains after sifting,
   *         and isIdentity is true if the residue is the identity
   */
  def sift(perm: Permutation): (Permutation, Boolean) = {
    var current = perm

    for (level <- levels) {
      val beta = level.basePoint
      val image = current(beta)

      level.cosetRep(image) match {
        case Some(rep) =>
          // Multiply on LEFT by inverse of coset representative: rep^{-1} * current
          // This ensures the result fixes the base point: (rep^{-1} * current)(β) = rep^{-1}(current(β)) = rep^{-1}(image) = β
          current = rep.inverse.compose(current)
        case None =>
          // Not in group - image not in orbit
          return (current, false)
      }
    }

    (current, current.isIdentity)
  }

  /**
   * Get the base points.
   */
  def base: Seq[Int] = levels.map(_.basePoint)

  /**
   * Get all strong generators.
   */
  def strongGenerators: Set[Permutation] = {
    levels.flatMap(_.generators).toSet
  }

  /**
   * Enumerate all group elements (warning: exponential in group size!)
   *
   * @param maxSize Maximum number of elements to enumerate
   * @return Iterator over group elements
   */
  def elements(maxSize: Int = 100000): Iterator[Permutation] = {
    if (levels.isEmpty) {
      Iterator(Permutation.identity(n))
    } else {
      new GroupElementIterator(this, maxSize)
    }
  }
}

/**
 * One level of the stabilizer chain.
 *
 * Represents G^(i-1) / G^(i) where G^(i) is the pointwise stabilizer
 * of base points β₁, ..., βᵢ.
 *
 * @param basePoint    The base point βᵢ
 * @param transversal  Map from orbit element to coset representative that maps basePoint to it
 * @param generators   Generators that act at this level
 */
case class StabilizerLevel(
  basePoint: Int,
  transversal: Map[Int, Permutation],
  generators: Set[Permutation]
) {
  def orbit: Set[Int] = transversal.keySet
  def orbitSize: Int = transversal.size

  /**
   * Get the coset representative that maps basePoint to target.
   * Returns None if target is not in the orbit.
   */
  def cosetRep(target: Int): Option[Permutation] = transversal.get(target)
}

/**
 * Mutable builder for constructing a BSGS.
 */
private class BSGSBuilder(val n: Int) {
  private val levels = mutable.ListBuffer[LevelBuilder]()
  private val random = new Random()

  // Number of random products to try without improvement before stopping
  private val maxFails = 50

  /**
   * Add a generator to the BSGS.
   */
  def addGenerator(gen: Permutation): Boolean = {
    if (gen.isIdentity) return false
    siftAndAdd(gen)
  }

  /**
   * Sift a permutation and add residue as new generator if needed.
   * Returns true if the BSGS was changed.
   */
  private def siftAndAdd(perm: Permutation): Boolean = {
    var current = perm
    var levelIdx = 0
    var changed = false

    while (!current.isIdentity) {
      if (levelIdx >= levels.length) {
        // Need a new level - find first non-fixed point
        val beta = (0 until n).find(i => current(i) != i).get
        levels += new LevelBuilder(beta, n)
        changed = true
      }

      val level = levels(levelIdx)
      val beta = level.basePoint
      val image = current(beta)

      level.transversal.get(image) match {
        case Some(rep) =>
          // Apply inverse of coset rep on LEFT to reduce: rep^{-1} * current
          current = rep.inverse.compose(current)
          levelIdx += 1

        case None =>
          // Image not in orbit - extend orbit and add generator
          level.addGenerator(current)
          changed = true
          // Continue sifting the same permutation
          level.transversal.get(image) match {
            case Some(rep) =>
              current = rep.inverse.compose(current)
              levelIdx += 1
            case None =>
              // Should not happen after adding generator
              throw new IllegalStateException("Failed to extend orbit")
          }
      }
    }

    changed
  }

  /**
   * Expand the BSGS using random Schreier products and Schreier generators.
   */
  def expand(): Unit = {
    var fails = 0

    while (fails < maxFails) {
      val changed = expandOnce()
      if (changed) {
        fails = 0
      } else {
        fails += 1
      }
    }
  }

  private def expandOnce(): Boolean = {
    // Collect all generators from all levels
    val allGens = levels.flatMap(_.generators.toSeq).toIndexedSeq
    if (allGens.isEmpty) return false

    var changed = false

    // Try a random product
    val wordLen = 1 + random.nextInt(4)
    var product = Permutation.identity(n)
    for (_ <- 0 until wordLen) {
      product = product.compose(allGens(random.nextInt(allGens.length)))
    }
    if (siftAndAdd(product)) changed = true

    // Try some Schreier generators
    val levelsCopy = levels.toList
    for (level <- levelsCopy) {
      val orbitList = level.transversal.keys.toList
      val gensList = level.generators.toList

      for (gen <- gensList; pt <- orbitList) {
        val image = gen(pt)
        (level.transversal.get(pt), level.transversal.get(image)) match {
          case (Some(u), Some(v)) =>
            // Schreier generator: v^{-1} * gen * u
            // u maps β to pt, v maps β to gen(pt)
            // h(β) = v^{-1}(gen(u(β))) = v^{-1}(gen(pt)) = v^{-1}(image) = β
            val schreierGen = v.inverse.compose(gen).compose(u)
            if (!schreierGen.isIdentity && siftAndAdd(schreierGen)) {
              changed = true
            }
          case _ => // Skip
        }
      }
    }

    changed
  }

  /**
   * Convert to immutable BSGS.
   */
  def toBSGS: BSGS = {
    val immutableLevels = levels.map { level =>
      StabilizerLevel(
        level.basePoint,
        level.transversal.toMap,
        level.generators.toSet
      )
    }.toList

    BSGS(immutableLevels, n)
  }

  /**
   * Mutable level builder.
   */
  private class LevelBuilder(val basePoint: Int, n: Int) {
    val transversal = mutable.Map[Int, Permutation](basePoint -> Permutation.identity(n))
    val generators = mutable.Set[Permutation]()

    /**
     * Add a generator and extend the orbit using BFS.
     */
    def addGenerator(gen: Permutation): Unit = {
      generators += gen

      // BFS to compute full orbit under all generators
      val queue = mutable.Queue[Int]()
      val currentOrbit = transversal.keySet.toSet

      for (pt <- currentOrbit) {
        queue.enqueue(pt)
      }

      while (queue.nonEmpty) {
        val pt = queue.dequeue()
        val rep = transversal(pt)

        for (g <- generators) {
          val image = g(pt)
          if (!transversal.contains(image)) {
            // Coset rep for image = g * rep (maps basePoint to image)
            // g.compose(rep)(basePoint) = g(rep(basePoint)) = g(pt) = image
            transversal(image) = g.compose(rep)
            queue.enqueue(image)
          }
        }
      }
    }
  }
}

/**
 * Iterator over group elements using the BSGS structure.
 */
private class GroupElementIterator(bsgs: BSGS, maxSize: Int) extends Iterator[Permutation] {
  private val n = bsgs.n
  private var count = 0

  // Current indices into each level's orbit
  private val indices = Array.fill(bsgs.levels.length)(0)
  private val orbits = bsgs.levels.map(_.orbit.toIndexedSeq).toArray
  private var exhausted = bsgs.levels.isEmpty

  override def hasNext: Boolean = !exhausted && count < maxSize

  override def next(): Permutation = {
    if (!hasNext) throw new NoSuchElementException

    // Compute current element
    var elem = Permutation.identity(n)
    for (i <- bsgs.levels.indices) {
      val pt = orbits(i)(indices(i))
      val rep = bsgs.levels(i).cosetRep(pt).get
      elem = elem.compose(rep)
    }

    count += 1

    // Advance indices (like incrementing a multi-digit number)
    var carry = true
    var i = bsgs.levels.length - 1
    while (carry && i >= 0) {
      indices(i) += 1
      if (indices(i) >= orbits(i).length) {
        indices(i) = 0
        i -= 1
      } else {
        carry = false
      }
    }

    if (carry) {
      exhausted = true
    }

    elem
  }
}
