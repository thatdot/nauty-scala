package com.thatdot.nauty.group

import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers

class SchreierSimsSpec extends AnyFlatSpec with Matchers {

  "SchreierSims.groupOrder" should "return 1 for trivial group" in {
    val order = SchreierSims.groupOrder(Nil, 5)
    order shouldBe BigInt(1)
  }

  it should "return 1 for identity generator" in {
    val order = SchreierSims.groupOrder(List(Permutation.identity(5)), 5)
    order shouldBe BigInt(1)
  }

  it should "return 2 for single transposition" in {
    val gen = Permutation.transposition(5, 0, 1)
    val order = SchreierSims.groupOrder(List(gen), 5)
    order shouldBe BigInt(2)
  }

  it should "return 3 for 3-cycle" in {
    val gen = Permutation.fromCycles(5, List(0, 1, 2))
    val order = SchreierSims.groupOrder(List(gen), 5)
    order shouldBe BigInt(3)
  }

  it should "return 6 for S3 (two generators)" in {
    // S3 is generated by (0 1) and (0 1 2)
    val gens = List(
      Permutation.transposition(3, 0, 1),
      Permutation.fromCycles(3, List(0, 1, 2))
    )
    val order = SchreierSims.groupOrder(gens, 3)
    order shouldBe BigInt(6)  // 3! = 6
  }

  it should "return 24 for S4" in {
    // S4 is generated by (0 1) and (0 1 2 3)
    val gens = List(
      Permutation.transposition(4, 0, 1),
      Permutation.cyclic(4)
    )
    val order = SchreierSims.groupOrder(gens, 4)
    order shouldBe BigInt(24)  // 4! = 24
  }

  it should "return 120 for S5" in {
    // S5 is generated by (0 1) and (0 1 2 3 4)
    val gens = List(
      Permutation.transposition(5, 0, 1),
      Permutation.cyclic(5)
    )
    val order = SchreierSims.groupOrder(gens, 5)
    order shouldBe BigInt(120)  // 5! = 120
  }

  it should "return 12 for A4 (alternating group)" in {
    // A4 is generated by (0 1 2) and (0 2 3)
    val gens = List(
      Permutation.fromCycles(4, List(0, 1, 2)),
      Permutation.fromCycles(4, List(0, 2, 3))
    )
    val order = SchreierSims.groupOrder(gens, 4)
    order shouldBe BigInt(12)  // 4!/2 = 12
  }

  it should "return 8 for D4 (dihedral group of square)" in {
    // D4 is generated by rotation (0 1 2 3) and reflection (0 2)
    val gens = List(
      Permutation.fromCycles(4, List(0, 1, 2, 3)),
      Permutation.transposition(4, 0, 2)
    )
    val order = SchreierSims.groupOrder(gens, 4)
    order shouldBe BigInt(8)  // 2 * 4 = 8
  }

  it should "return 10 for D5 (dihedral group of pentagon)" in {
    // D5 is generated by rotation (0 1 2 3 4) and reflection (1 4)(2 3)
    val gens = List(
      Permutation.fromCycles(5, List(0, 1, 2, 3, 4)),
      Permutation.fromCycles(5, List(1, 4), List(2, 3))
    )
    val order = SchreierSims.groupOrder(gens, 5)
    order shouldBe BigInt(10)  // 2 * 5 = 10
  }

  "SchreierSims.isMember" should "return true for identity" in {
    val gens = List(Permutation.transposition(3, 0, 1))
    SchreierSims.isMember(Permutation.identity(3), gens, 3) shouldBe true
  }

  it should "return true for generator" in {
    val gen = Permutation.transposition(3, 0, 1)
    SchreierSims.isMember(gen, List(gen), 3) shouldBe true
  }

  it should "return true for product of generators in S3" in {
    val gens = List(
      Permutation.transposition(3, 0, 1),
      Permutation.fromCycles(3, List(0, 1, 2))
    )
    // (0 1 2) composed with (0 1) = (0 2)
    val product = gens(1).compose(gens(0))
    SchreierSims.isMember(product, gens, 3) shouldBe true
  }

  it should "return false for element not in subgroup" in {
    // Group generated by (0 1) doesn't contain (0 2)
    val gens = List(Permutation.transposition(3, 0, 1))
    val notMember = Permutation.transposition(3, 0, 2)
    SchreierSims.isMember(notMember, gens, 3) shouldBe false
  }

  "BSGS.elements" should "enumerate all elements of S3" in {
    val gens = List(
      Permutation.transposition(3, 0, 1),
      Permutation.fromCycles(3, List(0, 1, 2))
    )
    val bsgs = SchreierSims.computeBSGS(gens, 3)
    val elements = bsgs.elements().toSet

    elements.size shouldBe 6  // |S3| = 6
    elements should contain(Permutation.identity(3))
    elements should contain(Permutation.transposition(3, 0, 1))
    elements should contain(Permutation.transposition(3, 0, 2))
    elements should contain(Permutation.transposition(3, 1, 2))
    elements should contain(Permutation.fromCycles(3, List(0, 1, 2)))
    elements should contain(Permutation.fromCycles(3, List(0, 2, 1)))
  }

  it should "enumerate all elements of Z3" in {
    val gens = List(Permutation.fromCycles(3, List(0, 1, 2)))
    val bsgs = SchreierSims.computeBSGS(gens, 3)
    val elements = bsgs.elements().toSet

    elements.size shouldBe 3
  }

  "BSGS.base" should "return base points" in {
    val gens = List(
      Permutation.transposition(4, 0, 1),
      Permutation.cyclic(4)
    )
    val bsgs = SchreierSims.computeBSGS(gens, 4)

    bsgs.base should not be empty
  }

  "BSGS.strongGenerators" should "return generators that generate the same group" in {
    val gens = List(
      Permutation.transposition(3, 0, 1),
      Permutation.fromCycles(3, List(0, 1, 2))
    )
    val bsgs = SchreierSims.computeBSGS(gens, 3)

    val strongGens = bsgs.strongGenerators
    strongGens should not be empty

    // The strong generators should generate the same group (S3 with order 6)
    val strongBsgs = SchreierSims.computeBSGS(strongGens.toSeq, 3)
    strongBsgs.order shouldBe bsgs.order
  }

  "Cyclic groups" should "have correct order" in {
    for (k <- 2 to 8) {
      val gen = Permutation.cyclic(k)
      val order = SchreierSims.groupOrder(List(gen), k)
      order shouldBe BigInt(k)
    }
  }

  "Klein four-group" should "have order 4" in {
    // V4 = {e, (0 1)(2 3), (0 2)(1 3), (0 3)(1 2)}
    val gens = List(
      Permutation.fromCycles(4, List(0, 1), List(2, 3)),
      Permutation.fromCycles(4, List(0, 2), List(1, 3))
    )
    val order = SchreierSims.groupOrder(gens, 4)
    order shouldBe BigInt(4)
  }
}
