package com.thatdot.nauty.core

import com.thatdot.nauty.graph.DenseGraph
import com.thatdot.nauty.group.{Permutation, Orbits}
import com.thatdot.nauty.util.NautyOptions

/**
 * Trace automorphism detection to understand redundancy.
 */
object AutomorphismTraceTest extends App {

  println("=== Automorphism Trace Test ===\n")

  val c5 = DenseGraph.cycle(5)
  val n = 5

  // Simulate the group size calculation as Scala does it
  println("Simulating group size calculation:")
  println("-" * 40)

  val orbits = Orbits.identity(n)
  println(s"Initial orbits: ${orbits.mkString(", ")} (${Orbits.numOrbits(orbits, n)} orbits)")
  var groupSize = 1

  val generators = Seq(
    Array(0, 4, 3, 2, 1),  // (1 4)(2 3)
    Array(1, 0, 4, 3, 2),  // (0 1)(2 4)
    Array(1, 2, 3, 4, 0)   // (0 1 2 3 4)
  )

  for ((gen, i) <- generators.zipWithIndex) {
    val oldOrbits = Orbits.numOrbits(orbits, n)
    val newOrbits = Orbits.orbjoin(orbits, gen, n)

    val orbitsMerged = oldOrbits - newOrbits
    val multiplier = if (orbitsMerged > 0) orbitsMerged + 1 else 2
    groupSize *= multiplier

    println(s"\nGenerator $i: ${Permutation.fromArray(gen).toCycleString}")
    println(s"  Orbits before: $oldOrbits, after: $newOrbits, merged: $orbitsMerged")
    println(s"  Multiplier: $multiplier")
    println(s"  Group size: $groupSize")
    println(s"  Orbits now: ${orbits.mkString(", ")}")
  }

  println(s"\nFinal computed group size: $groupSize")
  println("Expected: 10 (dihedral group D5)")
  println()

  // Show what the correct calculation should be
  println("Correct calculation using orbit-stabilizer:")
  println("-" * 40)
  println("D5 is generated by:")
  println("  r = (0 1 2 3 4) - rotation of order 5")
  println("  s = (1 4)(2 3) - reflection of order 2")
  println("|D5| = 2 * 5 = 10")
  println()

  // Check if (0 1)(2 4) is a consequence of r and s
  val r = Permutation.fromArray(Array(1, 2, 3, 4, 0))
  val s = Permutation.fromArray(Array(0, 4, 3, 2, 1))
  val t = Permutation.fromArray(Array(1, 0, 4, 3, 2))  // (0 1)(2 4)

  println("Checking if (0 1)(2 4) = some product of r and s:")
  // Try various products
  val products = Seq(
    ("s", s),
    ("r", r),
    ("r*s", r.compose(s)),
    ("s*r", s.compose(r)),
    ("r*r", r.compose(r)),
    ("r*s*r", r.compose(s).compose(r)),
    ("s*r*s", s.compose(r).compose(s)),
    ("r*r*s", r.compose(r).compose(s))
  )

  for ((name, p) <- products) {
    if (p == t) println(s"  FOUND: $name = ${p.toCycleString}")
  }

  // Generate all elements of D5 and check
  println("\nGenerating D5 from r and s:")
  var d5 = Set(Permutation.identity(5))
  var frontier = Set(r, s)

  while (frontier.nonEmpty) {
    d5 = d5 ++ frontier
    val next = for {
      g <- d5
      h <- Set(r, s)
      p <- Set(g.compose(h), h.compose(g))
      if !d5.contains(p)
    } yield p
    frontier = next
  }

  println(s"  |D5| = ${d5.size}")
  println(s"  D5 contains (0 1)(2 4)? ${d5.contains(t)}")
  println()

  // Now check which generator is redundant
  println("Checking generator independence:")
  println("-" * 40)

  val gen0 = Permutation.fromArray(Array(0, 4, 3, 2, 1))  // (1 4)(2 3)
  val gen1 = Permutation.fromArray(Array(1, 0, 4, 3, 2))  // (0 1)(2 4)
  val gen2 = Permutation.fromArray(Array(1, 2, 3, 4, 0))  // (0 1 2 3 4)

  // Generate group from gen0 and gen1
  var fromG01 = Set(Permutation.identity(5))
  var frontier01 = Set(gen0, gen1)
  while (frontier01.nonEmpty) {
    fromG01 = fromG01 ++ frontier01
    val next = for {
      g <- fromG01
      h <- Set(gen0, gen1)
      p <- Set(g.compose(h), h.compose(g))
      if !fromG01.contains(p)
    } yield p
    frontier01 = next
  }
  println(s"Group from gen0, gen1: size = ${fromG01.size}")
  println(s"  Contains gen2? ${fromG01.contains(gen2)}")

  // Generate group from gen0 and gen2
  var fromG02 = Set(Permutation.identity(5))
  var frontier02 = Set(gen0, gen2)
  while (frontier02.nonEmpty) {
    fromG02 = fromG02 ++ frontier02
    val next = for {
      g <- fromG02
      h <- Set(gen0, gen2)
      p <- Set(g.compose(h), h.compose(g))
      if !fromG02.contains(p)
    } yield p
    frontier02 = next
  }
  println(s"Group from gen0, gen2: size = ${fromG02.size}")
  println(s"  Contains gen1? ${fromG02.contains(gen1)}")

  println()
  println("CONCLUSION:")
  if (fromG01.size == 10 && fromG01.contains(gen2)) {
    println("  gen2 is REDUNDANT (derivable from gen0 and gen1)")
    println("  The algorithm should NOT be finding gen2 as a new generator")
  }
  if (fromG02.size == 10 && fromG02.contains(gen1)) {
    println("  gen1 is REDUNDANT if we have gen0 and gen2")
  }
}
