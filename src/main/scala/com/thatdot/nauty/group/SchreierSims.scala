package com.thatdot.nauty.group

import scala.collection.mutable
import scala.util.Random

/**
 * Schreier-Sims algorithm for computing a Base and Strong Generating Set (BSGS)
 * of a permutation group.
 *
 * This implementation closely follows the C nauty schreier.c implementation:
 * - Uses union-find with path compression for orbit tracking
 * - Stores transversals as (generator, power) pairs instead of full permutations
 * - filterschreier simultaneously sifts and extends transversals
 *
 * This allows:
 * - Accurate computation of group order
 * - Membership testing
 * - Enumeration of group elements
 */
object SchreierSims {

  /**
   * Compute a BSGS for the group generated by the given permutations.
   *
   * @param generators List of generators for the group
   * @param n          Degree of the permutation group (permutations act on 0..n-1)
   * @return A BSGS structure representing the group
   */
  def computeBSGS(generators: Seq[Permutation], n: Int): BSGS = {
    if (generators.isEmpty || n == 0) {
      return BSGS(Nil, n)
    }

    val builder = new SchreierBuilder(n)

    // Add all generators via filterschreier
    for (gen <- generators if !gen.isIdentity) {
      builder.filterschreier(gen.toArray, inGroup = false)
    }

    // Like C nauty's grouporder():
    // - getorbits() calls expandschreier() once
    // - grouporder() then calls expandschreier() twice more
    builder.expandschreier()
    builder.expandschreier()
    builder.expandschreier()

    builder.toBSGS
  }

  /**
   * Compute the order of the group generated by the given permutations.
   *
   * @param generators List of generators
   * @param n          Degree of the group
   * @return The group order as a BigInt
   */
  def groupOrder(generators: Seq[Permutation], n: Int): BigInt = {
    val bsgs = computeBSGS(generators, n)
    bsgs.order
  }

  /**
   * Test if a permutation is in the group generated by the given generators.
   *
   * @param perm       The permutation to test
   * @param generators The generators of the group
   * @param n          Degree of the group
   * @return true if perm is in the group
   */
  def isMember(perm: Permutation, generators: Seq[Permutation], n: Int): Boolean = {
    val bsgs = computeBSGS(generators, n)
    bsgs.contains(perm)
  }
}

/**
 * A Base and Strong Generating Set (BSGS) representation of a permutation group.
 *
 * @param levels The stabilizer chain levels
 * @param n      Degree of the group
 */
case class BSGS(levels: List[StabilizerLevel], n: Int) {

  /**
   * Compute the order of the group.
   * This is the product of orbit sizes at each level.
   */
  def order: BigInt = {
    if (levels.isEmpty) BigInt(1)
    else levels.map(level => BigInt(level.orbitSize)).product
  }

  /**
   * Test if a permutation is in the group.
   */
  def contains(perm: Permutation): Boolean = {
    sift(perm)._2
  }

  /**
   * Sift a permutation through the stabilizer chain.
   *
   * @param perm The permutation to sift
   * @return (residue, isIdentity) where residue is what remains after sifting,
   *         and isIdentity is true if the residue is the identity
   */
  def sift(perm: Permutation): (Permutation, Boolean) = {
    var current = perm
    var i = 0
    var inGroup = true
    while (i < levels.length && inGroup) {
      val level = levels(i)
      val beta = level.basePoint
      val image = current(beta)

      level.cosetRep(image) match {
        case Some(rep) =>
          // Multiply on LEFT by inverse of coset representative: rep^{-1} * current
          // This ensures the result fixes the base point: (rep^{-1} * current)(β) = rep^{-1}(current(β)) = rep^{-1}(image) = β
          current = rep.inverse.compose(current)
        case None =>
          // Not in group - image not in orbit
          inGroup = false
      }
      i += 1
    }

    if (inGroup) (current, current.isIdentity)
    else (current, false)
  }

  /**
   * Get the base points.
   */
  def base: Seq[Int] = levels.map(_.basePoint)

  /**
   * Get all strong generators.
   */
  def strongGenerators: Set[Permutation] = {
    levels.flatMap(_.generators).toSet
  }

  /**
   * Enumerate all group elements (warning: exponential in group size!)
   *
   * @param maxSize Maximum number of elements to enumerate
   * @return Iterator over group elements
   */
  def elements(maxSize: Int = 100000): Iterator[Permutation] = {
    if (levels.isEmpty) {
      Iterator(Permutation.identity(n))
    } else {
      new GroupElementIterator(this, maxSize)
    }
  }
}

/**
 * One level of the stabilizer chain.
 *
 * Represents G^(i-1) / G^(i) where G^(i) is the pointwise stabilizer
 * of base points β₁, ..., βᵢ.
 *
 * @param basePoint    The base point βᵢ
 * @param transversal  Map from orbit element to coset representative that maps basePoint to it
 * @param generators   Generators that act at this level
 */
case class StabilizerLevel(
  basePoint: Int,
  transversal: Map[Int, Permutation],
  generators: Set[Permutation]
) {
  def orbit: Set[Int] = transversal.keySet
  def orbitSize: Int = transversal.size

  /**
   * Get the coset representative that maps basePoint to target.
   * Returns None if target is not in the orbit.
   */
  def cosetRep(target: Int): Option[Permutation] = transversal.get(target)
}

/**
 * Mutable builder matching C nauty's schreier structure.
 *
 * Each level has:
 * - vec[i]: permutation that moves i toward the orbit representative (or null if not in orbit)
 * - pwr[i]: power of vec[i] to apply
 * - orbits[i]: union-find structure for orbits
 * - fixed: the base point for this level
 */
private class SchreierBuilder(val n: Int) {
  // Match C's SCHREIERFAILS constant exactly
  private val SCHREIERFAILS = 10

  // List of all generators (simulates C's circular permnode list)
  private val generators = mutable.ArrayBuffer[Array[Int]]()

  // Stabilizer chain levels
  private val levels = mutable.ArrayBuffer[SchreierLevel]()

  // The C nauty code uses a deterministic PRNG (KRAN macro defined in naurng.h)
  // with built-in default seed values, making the randomized Schreier-Sims
  // algorithm reproducible. We use a fixed seed here to match that behavior.
  private val random = new Random(0x5EED_CAFE_BABEL)
  private val workperm = new Array[Int](n)

  /**
   * Filter permutation p through the stabilizer chain.
   * Like C's filterschreier(), this simultaneously:
   * - Updates orbits via union-find
   * - Extends transversals with (vec, pwr) entries
   * - Sifts through the chain
   *
   * @param p The permutation (as array)
   * @param inGroup True if p is known to be in the group
   * @return True if any change was made to the structure
   */
  def filterschreier(p: Array[Int], inGroup: Boolean): Boolean = {
    // Copy to working permutation
    System.arraycopy(p, 0, workperm, 0, n)

    var changed = false
    var levelIdx = 0
    var currentInGroup = inGroup
    var addedToGens = false

    while (true) {
      // Check if workperm is identity
      var isIdent = true
      var i = 0
      while (i < n && isIdent) {
        if (workperm(i) != i) isIdent = false
        i += 1
      }
      if (isIdent) return changed

      // Ensure we have enough levels
      if (levelIdx >= levels.length) {
        // Find first non-fixed point as base
        val beta = (0 until n).find(i => workperm(i) != i).get
        levels += new SchreierLevel(beta, n)
        changed = true
      }

      val level = levels(levelIdx)

      // Update orbits using union-find (like C's lines 597-612)
      var lchanged = false
      for (i <- 0 until n) {
        val j1 = level.findOrbitRep(i)
        val j2 = level.findOrbitRep(workperm(i))

        if (j1 != j2) {
          lchanged = true
          // Union: smaller becomes parent of larger
          if (j1 < j2) level.orbits(j2) = j1
          else level.orbits(j1) = j2
        }
      }

      // Path compression (like C's line 612)
      if (lchanged) {
        for (i <- 0 until n) {
          level.orbits(i) = level.findOrbitRep(i)
        }
        changed = true
      }

      // Extend transversal for new orbit elements (like C's lines 618-638)
      for (i <- 0 until n) {
        if (level.vec(i) != null && level.vec(workperm(i)) == null) {
          changed = true

          // Count how many steps from workperm(i) to reach a known element
          var ipwr = 0
          var j = workperm(i)
          while (level.vec(j) == null) {
            ipwr += 1
            j = workperm(j)
          }

          // Fill in vec/pwr for the chain
          j = workperm(i)
          while (level.vec(j) == null) {
            // Add workperm to generators if not already
            if (!addedToGens) {
              if (!currentInGroup) {
                addGenerator(workperm.clone())
              } else {
                addGeneratorUnmarked(workperm.clone())
              }
              currentInGroup = true
              addedToGens = true
            }
            level.vec(j) = generators.last
            level.pwr(j) = ipwr
            ipwr -= 1
            j = workperm(j)
          }
        }
      }

      // Apply coset representatives to reach next level (like C's lines 640-648)
      val fixed = level.fixed
      var target = workperm(fixed)

      while (target != fixed) {
        // Apply vec[target]^pwr[target] to workperm
        applyPerm(workperm, level.vec(target), level.pwr(target))
        addedToGens = false  // After applying, workperm may be different
        target = workperm(fixed)
      }

      levelIdx += 1
    }

    // Unreachable, but compiler wants this
    changed
  }

  /**
   * Apply permutation p^k to workperm (like C's applyperm).
   */
  private def applyPerm(wp: Array[Int], p: Array[Int], k: Int): Unit = {
    if (k == 0) return

    if (k <= 5) {
      if (k == 1) {
        for (i <- 0 until n) wp(i) = p(wp(i))
      } else if (k == 2) {
        for (i <- 0 until n) wp(i) = p(p(wp(i)))
      } else if (k == 3) {
        for (i <- 0 until n) wp(i) = p(p(p(wp(i))))
      } else if (k == 4) {
        for (i <- 0 until n) wp(i) = p(p(p(p(wp(i)))))
      } else { // k == 5
        for (i <- 0 until n) wp(i) = p(p(p(p(p(wp(i))))))
      }
    } else {
      // For larger k, use repeated application
      for (_ <- 0 until k) {
        for (i <- 0 until n) wp(i) = p(wp(i))
      }
    }
  }

  private def addGenerator(p: Array[Int]): Unit = {
    generators += p
  }

  private def addGeneratorUnmarked(p: Array[Int]): Unit = {
    generators += p
  }

  /**
   * Expand the BSGS using random products (like C's expandschreier).
   */
  def expandschreier(): Boolean = {
    if (generators.isEmpty) return false

    var nfails = 0
    var changed = false

    // Start with a random skip like C: KRAN(17) gives 0-16
    var pnIdx = 0
    var skips = random.nextInt(17)
    while (skips > 0) {
      pnIdx = (pnIdx + 1) % generators.length
      skips -= 1
    }
    val workperm2 = generators(pnIdx).clone()

    while (nfails < SCHREIERFAILS) {
      // Random word of length 1-4 (like C's wordlen = 1 + KRAN(3))
      val wordlen = 1 + random.nextInt(4)

      for (_ <- 0 until wordlen) {
        // Skip random number like C's KRAN(17): 0-16 independent of generator count
        skips = random.nextInt(17)
        while (skips > 0) {
          pnIdx = (pnIdx + 1) % generators.length
          skips -= 1
        }

        // Compose: workperm2 := generators(pnIdx) ∘ workperm2
        val gen = generators(pnIdx)
        for (i <- 0 until n) workperm2(i) = gen(workperm2(i))
      }

      if (filterschreier(workperm2, inGroup = true)) {
        changed = true
        nfails = 0
      } else {
        nfails += 1
      }
    }

    changed
  }

  /**
   * Convert to immutable BSGS.
   */
  def toBSGS: BSGS = {
    val immutableLevels = levels.map { level =>
      // Build transversal from vec/pwr chain computed during filterschreier
      // The coset representative for target maps fixed -> target
      // We compute it by following the vec/pwr chain backward
      val transversal = mutable.Map[Int, Permutation]()

      for (target <- 0 until n if level.vec(target) != null) {
        if (target == level.fixed) {
          transversal(target) = Permutation.identity(n)
        } else {
          // Compute coset rep by following chain from target to fixed,
          // then inverting. The chain goes: target --(vec^pwr)--> ... --> fixed
          // The coset rep is the inverse of composing vec^pwr along the chain
          val chainPerms = mutable.ArrayBuffer[Permutation]()
          var current = target

          while (current != level.fixed) {
            val vec = level.vec(current)
            val pwr = level.pwr(current)

            if (vec == null) {
              throw new IllegalStateException(s"vec($current) is null in chain to ${level.fixed}")
            }

            // Build vec^pwr as a permutation
            val vecPerm = Permutation.fromArray(vec)
            var powered = Permutation.identity(n)
            for (_ <- 0 until pwr) {
              powered = vecPerm.compose(powered)
            }
            chainPerms += powered

            // Move along chain
            var next = current
            for (_ <- 0 until pwr) {
              next = vec(next)
            }
            current = next
          }

          // Coset rep = inverse of (chain perms composed in order)
          // chain goes target -> ... -> fixed
          // To go fixed -> target, we apply inverses in reverse order
          var cosetRep = Permutation.identity(n)
          for (p <- chainPerms.reverse) {
            cosetRep = p.inverse.compose(cosetRep)
          }
          transversal(target) = cosetRep
        }
      }

      // Collect generators for this level
      val levelGens = generators.map(Permutation.fromArray).toSet

      StabilizerLevel(
        level.fixed,
        transversal.toMap,
        levelGens
      )
    }.toList

    BSGS(immutableLevels, n)
  }
}

/**
 * One level of the schreier structure (like C's schreier struct).
 */
private class SchreierLevel(val fixed: Int, n: Int) {
  // vec[i] = generator that moves i toward the orbit representative
  val vec: Array[Array[Int]] = new Array[Array[Int]](n)

  // pwr[i] = power of vec[i] to apply
  val pwr: Array[Int] = new Array[Int](n)

  // Union-find structure for orbits
  val orbits: Array[Int] = Array.tabulate(n)(identity)

  // Initialize: fixed point is in its own orbit with identity
  vec(fixed) = Array.tabulate(n)(identity) // Identity permutation
  pwr(fixed) = 0

  /**
   * Find orbit representative using path compression.
   */
  def findOrbitRep(i: Int): Int = {
    var j = i
    while (orbits(j) != j) {
      j = orbits(j)
    }
    // Path compression
    var k = i
    while (orbits(k) != j) {
      val next = orbits(k)
      orbits(k) = j
      k = next
    }
    j
  }

  /**
   * Count elements with non-null vec entries (orbit size).
   */
  def orbitSize: Int = vec.count(_ != null)
}

/**
 * Iterator over group elements using the BSGS structure.
 */
private class GroupElementIterator(bsgs: BSGS, maxSize: Int) extends Iterator[Permutation] {
  private val n = bsgs.n
  private var count = 0

  // Current indices into each level's orbit
  private val indices = Array.fill(bsgs.levels.length)(0)
  private val orbits = bsgs.levels.map(_.orbit.toIndexedSeq).toArray
  private var exhausted = bsgs.levels.isEmpty

  override def hasNext: Boolean = !exhausted && count < maxSize

  override def next(): Permutation = {
    if (!hasNext) throw new NoSuchElementException

    // Compute current element
    var elem = Permutation.identity(n)
    for (i <- bsgs.levels.indices) {
      val pt = orbits(i)(indices(i))
      val rep = bsgs.levels(i).cosetRep(pt).get
      elem = elem.compose(rep)
    }

    count += 1

    // Advance indices (like incrementing a multi-digit number)
    var carry = true
    var i = bsgs.levels.length - 1
    while (carry && i >= 0) {
      indices(i) += 1
      if (indices(i) >= orbits(i).length) {
        indices(i) = 0
        i -= 1
      } else {
        carry = false
      }
    }

    if (carry) {
      exhausted = true
    }

    elem
  }
}
